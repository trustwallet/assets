{
    "name": "ORBI",
    "type": "BEP20",
    "symbol": "ORB",
    "decimals": 18,
    "website": "https://linktr.ee/admin/links",
    "description": "ORBI is a Binance Smart Chain token built with the community at its core. We believe in creating a fair and transparent project where every holder has a voice. ORBI aims to provide a simple, low-cost way for people to get involved in DeFi, with real opportunities for growth through staking and liquidity. This isn’t just a token—it’s a community coming together to build something meaningful and lasting.",
    "explorer": "https://bscscan.com/token/0x5E721C98652123D0DC98c84518110696C497F3C9",
    "status": "active",
    "id": "0x5E721C98652123D0DC98c84518110696C497F3C9",
    "links": [
        {
            "name": "x",
            "url": "https://x.comm/biratpaudel2"
        },
        {
            "name": "github",
            "url": "https://github.com/Birat99/assets"
        },
        {
            "name": "telegram_news",
            "url": "https://t.me/bir"
        },
        {
            "name": "source_code",
            "url": "/**  *Submitted for verification at BscScan.com on 2023-05-15 */  /* // Official DxBurn Token // To Mint your own token visit https://dx.app // DxMint verified tokens are unruggable through code // To view the audit certificate for this token search it in https://dx.app/dxmint // Please ensure one wallet doesn't hold too much supply of tokens! */  // SPDX-License-Identifier: MIT  pragma solidity 0.8.7; pragma experimental ABIEncoderV2;   /**  * @dev Interface of the ERC20 standard as defined in the EIP.  */ interface IERC20 {     /**      * @dev Emitted when `value` tokens are moved from one account (`from`) to      * another (`to`).      *      * Note that `value` may be zero.      */     event Transfer(address indexed from, address indexed to, uint256 value);      /**      * @dev Emitted when the allowance of a `spender` for an `owner` is set by      * a call to {approve}. `value` is the new allowance.      */     event Approval(address indexed owner, address indexed spender, uint256 value);      /**      * @dev Returns the amount of tokens in existence.      */     function totalSupply() external view returns (uint256);      /**      * @dev Returns the amount of tokens owned by `account`.      */     function balanceOf(address account) external view returns (uint256);      /**      * @dev Moves `amount` tokens from the caller's account to `to`.      *      * Returns a boolean value indicating whether the operation succeeded.      *      * Emits a {Transfer} event.      */     function transfer(address to, uint256 amount) external returns (bool);      /**      * @dev Returns the remaining number of tokens that `spender` will be      * allowed to spend on behalf of `owner` through {transferFrom}. This is      * zero by default.      *      * This value changes when {approve} or {transferFrom} are called.      */     function allowance(address owner, address spender) external view returns (uint256);      /**      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.      *      * Returns a boolean value indicating whether the operation succeeded.      *      * IMPORTANT: Beware that changing an allowance with this method brings the risk      * that someone may use both the old and the new allowance by unfortunate      * transaction ordering. One possible solution to mitigate this race      * condition is to first reduce the spender's allowance to 0 and set the      * desired value afterwards:      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729      *      * Emits an {Approval} event.      */     function approve(address spender, uint256 amount) external returns (bool);      /**      * @dev Moves `amount` tokens from `from` to `to` using the      * allowance mechanism. `amount` is then deducted from the caller's      * allowance.      *      * Returns a boolean value indicating whether the operation succeeded.      *      * Emits a {Transfer} event.      */     function transferFrom(address from, address to, uint256 amount) external returns (bool); }   /**  * @dev Interface for the optional metadata functions from the ERC20 standard.  *  * _Available since v4.1._  */ interface IERC20Metadata is IERC20 {     /**      * @dev Returns the name of the token.      */     function name() external view returns (string memory);      /**      * @dev Returns the symbol of the token.      */     function symbol() external view returns (string memory);      /**      * @dev Returns the decimals places of the token.      */     function decimals() external view returns (uint8); }   /**  * @dev Provides information about the current execution context, including the  * sender of the transaction and its data. While these are generally available  * via msg.sender and msg.data, they should not be accessed in such a direct  * manner, since when dealing with meta-transactions the account sending and  * paying for execution may not be the actual sender (as far as an application  * is concerned).  *  * This contract is only required for intermediate, library-like contracts.  */ abstract contract Context {     function _msgSender() internal view virtual returns (address) {         return msg.sender;     }      function _msgData() internal view virtual returns (bytes calldata) {         return msg.data;     } }   /**  * @dev Contract module which provides a basic access control mechanism, where  * there is an account (an owner) that can be granted exclusive access to  * specific functions.  *  * By default, the owner account will be the one that deploys the contract. This  * can later be changed with {transferOwnership}.  *  * This module is used through inheritance. It will make available the modifier  * `onlyOwner`, which can be applied to your functions to restrict their use to  * the owner.  */ abstract contract Ownable is Context {     address private _owner;      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);      /**      * @dev Initializes the contract setting the deployer as the initial owner.      */     constructor() {         _transferOwnership(_msgSender());     }      /**      * @dev Throws if called by any account other than the owner.      */     modifier onlyOwner() {         _checkOwner();         _;     }      /**      * @dev Returns the address of the current owner.      */     function owner() public view virtual returns (address) {         return _owner;     }      /**      * @dev Throws if the sender is not the owner.      */     function _checkOwner() internal view virtual {         require(owner() == _msgSender(), \"Ownable: caller is not the owner\");     }      /**      * @dev Leaves the contract without owner. It will not be possible to call      * `onlyOwner` functions. Can only be called by the current owner.      *      * NOTE: Renouncing ownership will leave the contract without an owner,      * thereby disabling any functionality that is only available to the owner.      */     function renounceOwnership() public virtual onlyOwner {         _transferOwnership(address(0));     }      /**      * @dev Transfers ownership of the contract to a new account (`newOwner`).      * Can only be called by the current owner.      */     function transferOwnership(address newOwner) public virtual onlyOwner {         require(newOwner != address(0), \"Ownable: new owner is the zero address\");         _transferOwnership(newOwner);     }      /**      * @dev Transfers ownership of the contract to a new account (`newOwner`).      * Internal function without access restriction.      */     function _transferOwnership(address newOwner) internal virtual {         address oldOwner = _owner;         _owner = newOwner;         emit OwnershipTransferred(oldOwner, newOwner);     } }   /**  * @dev Collection of functions related to the address type  */ library Address {     /**      * @dev Returns true if `account` is a contract.      *      * [IMPORTANT]      * ====      * It is unsafe to assume that an address for which this function returns      * false is an externally-owned account (EOA) and not a contract.      *      * Among others, `isContract` will return false for the following      * types of addresses:      *      *  - an externally-owned account      *  - a contract in construction      *  - an address where a contract will be created      *  - an address where a contract lived, but was destroyed      *      * Furthermore, `isContract` will also return true if the target contract within      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,      * which only has an effect at the end of a transaction.      * ====      *      * [IMPORTANT]      * ====      * You shouldn't rely on `isContract` to protect against flash loan attacks!      *      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract      * constructor.      * ====      */     function isContract(address account) internal view returns (bool) {         // This method relies on extcodesize/address.code.length, which returns 0         // for contracts in construction, since the code is only stored at the end         // of the constructor execution.          return account.code.length > 0;     }      /**      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to      * `recipient`, forwarding all available gas and reverting on errors.      *      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost      * of certain opcodes, possibly making contracts go over the 2300 gas limit      * imposed by `transfer`, making them unable to receive funds via      * `transfer`. {sendValue} removes this limitation.      *      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].      *      * IMPORTANT: because control is transferred to `recipient`, care must be      * taken to not create reentrancy vulnerabilities. Consider using      * {ReentrancyGuard} or the      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].      */     function sendValue(address payable recipient, uint256 amount) internal {         require(address(this).balance >= amount, \"Address: insufficient balance\");          (bool success, ) = recipient.call{value: amount}(\"\");         require(success, \"Address: unable to send value, recipient may have reverted\");     }      /**      * @dev Performs a Solidity function call using a low level `call`. A      * plain `call` is an unsafe replacement for a function call: use this      * function instead.      *      * If `target` reverts with a revert reason, it is bubbled up by this      * function (like regular Solidity function calls).      *      * Returns the raw returned data. To convert to the expected return value,      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].      *      * Requirements:      *      * - `target` must be a contract.      * - calling `target` with `data` must not revert.      *      * _Available since v3.1._      */     function functionCall(address target, bytes memory data) internal returns (bytes memory) {         return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with      * `errorMessage` as a fallback revert reason when `target` reverts.      *      * _Available since v3.1._      */     function functionCall(         address target,         bytes memory data,         string memory errorMessage     ) internal returns (bytes memory) {         return functionCallWithValue(target, data, 0, errorMessage);     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],      * but also transferring `value` wei to `target`.      *      * Requirements:      *      * - the calling contract must have an ETH balance of at least `value`.      * - the called Solidity function must be `payable`.      *      * _Available since v3.1._      */     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {         return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");     }      /**      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but      * with `errorMessage` as a fallback revert reason when `target` reverts.      *      * _Available since v3.1._      */     function functionCallWithValue(         address target,         bytes memory data,         uint256 value,         string memory errorMessage     ) internal returns (bytes memory) {         require(address(this).balance >= value, \"Address: insufficient balance for call\");         (bool success, bytes memory returndata) = target.call{value: value}(data);         return verifyCallResultFromTarget(target, success, returndata, errorMessage);     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],      * but performing a static call.      *      * _Available since v3.3._      */     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {         return functionStaticCall(target, data, \"Address: low-level static call failed\");     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],      * but performing a static call.      *      * _Available since v3.3._      */     function functionStaticCall(         address target,         bytes memory data,         string memory errorMessage     ) internal view returns (bytes memory) {         (bool success, bytes memory returndata) = target.staticcall(data);         return verifyCallResultFromTarget(target, success, returndata, errorMessage);     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],      * but performing a delegate call.      *      * _Available since v3.4._      */     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {         return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");     }      /**      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],      * but performing a delegate call.      *      * _Available since v3.4._      */     function functionDelegateCall(         address target,         bytes memory data,         string memory errorMessage     ) internal returns (bytes memory) {         (bool success, bytes memory returndata) = target.delegatecall(data);         return verifyCallResultFromTarget(target, success, returndata, errorMessage);     }      /**      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.      *      * _Available since v4.8._      */     function verifyCallResultFromTarget(         address target,         bool success,         bytes memory returndata,         string memory errorMessage     ) internal view returns (bytes memory) {         if (success) {             if (returndata.length == 0) {                 // only check isContract if the call was successful and the return data is empty                 // otherwise we already know that it was a contract                 require(isContract(target), \"Address: call to non-contract\");             }             return returndata;         } else {             _revert(returndata, errorMessage);         }     }      /**      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the      * revert reason or using the provided one.      *      * _Available since v4.3._      */     function verifyCallResult(         bool success,         bytes memory returndata,         string memory errorMessage     ) internal pure returns (bytes memory) {         if (success) {             return returndata;         } else {             _revert(returndata, errorMessage);         }     }      function _revert(bytes memory returndata, string memory errorMessage) private pure {         // Look for revert reason and bubble it up if present         if (returndata.length > 0) {             // The easiest way to bubble the revert reason is using memory via assembly             /// @solidity memory-safe-assembly             assembly {                 let returndata_size := mload(returndata)                 revert(add(32, returndata), returndata_size)             }         } else {             revert(errorMessage);         }     } }   contract DxBurnToken is Context, IERC20, IERC20Metadata,Ownable {     bool public mintedByDxsale = true;     uint256 private _totalSupply;     bool public mintingFinishedPermanent = false;     string private _name;     string private _symbol;     uint8 private _decimals;     address public _creator;     uint8 public _burnFee;     uint8 public _devFee;     uint256 public _maxBurnFee;     uint256 public _maxDevFee;     address public _devWalletAddress;      mapping (address => uint256) private _balances;     mapping (address => mapping (address => uint256)) private _allowances;     mapping (address => bool) private _isExcludedFromFee;     mapping (address => bool) private _isdevWallet;      constructor (address creator_,string memory name_, string memory symbol_,uint8 decimals_, uint256 tokenSupply_, uint8 burnFee_, uint8 devFee_, uint256 maxBurnFee_, uint256 maxDevFee_, address devWalletAddress_) {         _name = name_;         _symbol = symbol_;         _decimals = decimals_;         _creator = creator_;         _burnFee = burnFee_;         _devFee = devFee_;         _maxBurnFee = maxBurnFee_;         _maxDevFee = maxDevFee_;         _devWalletAddress = devWalletAddress_;          //excluded addresses from fees         _isExcludedFromFee[creator_] = true;         _isExcludedFromFee[address(this)] = true;         _isExcludedFromFee[_devWalletAddress] = true;              //set wallet provided to true         _isdevWallet[_devWalletAddress] = true;                   _mint(_creator,tokenSupply_);         mintingFinishedPermanent = true;     }      /**      * @dev Returns the name of the token.      */     function name() public view virtual override returns (string memory) {         return _name;     }      /**      * @dev Returns the symbol of the token, usually a shorter version of the      * name.      */     function symbol() public view virtual override returns (string memory) {         return _symbol;     }      /**      * @dev Returns the number of decimals used to get its user representation.      * For example, if `decimals` equals `2`, a balance of `505` tokens should      * be displayed to a user as `5,05` (`505 / 10 ** 2`).      *      * Tokens usually opt for a value of 18, imitating the relationship between      * Ether and Wei. This is the value {ERC20} uses, unless this function is      * overridden;      *      * NOTE: This information is only used for _display_ purposes: it in      * no way affects any of the arithmetic of the contract, including      * {IERC20-balanceOf} and {IERC20-transfer}.      */     function decimals() public view virtual override returns (uint8) {         return _decimals;     }      /**      * @dev See {IERC20-totalSupply}.      */     function totalSupply() public view virtual override returns (uint256) {         return _totalSupply;     }      /**      * @dev See {IERC20-balanceOf}.      */     function balanceOf(address account) public view virtual override returns (uint256) {         return _balances[account];     }      /**      * @dev See {IERC20-transfer}.      *      * Requirements:      *      * - `recipient` cannot be the zero address.      * - the caller must have a balance of at least `amount`.      */     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         _transfer(_msgSender(), recipient, amount);         return true;     }      /**      * @dev See {IERC20-allowance}.      */     function allowance(address owner, address spender) public view virtual override returns (uint256) {         return _allowances[owner][spender];     }      /**      * @dev See {IERC20-approve}.      *      * Requirements:      *      * - `spender` cannot be the zero address.      */     function approve(address spender, uint256 amount) public virtual override returns (bool) {         _approve(_msgSender(), spender, amount);         return true;     }      /**      * @dev See {IERC20-transferFrom}.      *      * Emits an {Approval} event indicating the updated allowance. This is not      * required by the EIP. See the note at the beginning of {ERC20}.      *      * Requirements:      *      * - `sender` and `recipient` cannot be the zero address.      * - `sender` must have a balance of at least `amount`.      * - the caller must have allowance for ``sender``'s tokens of at least      * `amount`.      */     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");         _approve(sender, _msgSender(), currentAllowance - amount);          return true;     }      /**      * @dev Atomically increases the allowance granted to `spender` by the caller.      *      * This is an alternative to {approve} that can be used as a mitigation for      * problems described in {IERC20-approve}.      *      * Emits an {Approval} event indicating the updated allowance.      *      * Requirements:      *      * - `spender` cannot be the zero address.      */     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);         return true;     }      /**      * @dev Atomically decreases the allowance granted to `spender` by the caller.      *      * This is an alternative to {approve} that can be used as a mitigation for      * problems described in {IERC20-approve}.      *      * Emits an {Approval} event indicating the updated allowance.      *      * Requirements:      *      * - `spender` cannot be the zero address.      * - `spender` must have allowance for the caller of at least      * `subtractedValue`.      */     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {         uint256 currentAllowance = _allowances[_msgSender()][spender];         require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");         _approve(_msgSender(), spender, currentAllowance - subtractedValue);          return true;     }      function isExcludedFromFee(address account) public view returns (bool) {         return _isExcludedFromFee[account];     }      function excludeFromFee(address account) public onlyOwner {         require(!_isExcludedFromFee[account], \"Account is already excluded\");         _isExcludedFromFee[account] = true;     }          function includeInFee(address account) public onlyOwner {         require(_isExcludedFromFee[account], \"Account is already included\");         _isExcludedFromFee[account] = false;     }              function setDevWalletAddress(address _addr) internal virtual {         if (!_isExcludedFromFee[_addr]) {             excludeFromFee(_addr);         }         _isdevWallet[_addr] = true;         _devWalletAddress = _addr;     }      function replaceDevWalletAddress(address _addr, address _newAddr) public onlyOwner {         require(_isdevWallet[_addr], \"Wallet address not set previously\");         require(!_isdevWallet[_newAddr], \"Wallet address already set\");         if (_isExcludedFromFee[_addr]) {             includeInFee(_addr);         }         _isdevWallet[_addr] = false;         setDevWalletAddress(_newAddr);     }      function setDevFeePercent(uint8 devFee) external onlyOwner() {         require(devFee >= 0 && devFee <= _maxDevFee,\"teamFee out of range\");         _devFee = devFee;     }            function setBurnFeePercent(uint8 burnFee) external onlyOwner() {         require(burnFee >= 0 && burnFee <= _maxBurnFee,\"teamFee out of range\");         _burnFee = burnFee;     }           function burn(uint256 _value) public {         _burn(msg.sender, _value);     }       /**      * @dev Moves tokens `amount` from `sender` to `recipient`.      *      * This is internal function is equivalent to {transfer}, and can be used to      * e.g. implement automatic token fees, slashing mechanisms, etc.      *      * Emits a {Transfer} event.      *      * Requirements:      *      * - `sender` cannot be the zero address.      * - `recipient` cannot be the zero address.      * - `sender` must have a balance of at least `amount`.      */     function _transfer(address sender, address recipient, uint256 amount) internal virtual {         require(sender != address(0), \"ERC20: transfer from the zero address\");         require(recipient != address(0), \"ERC20: transfer to the zero address\");           uint256 senderBalance = _balances[sender];         require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");          if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){             _balances[sender] = senderBalance - amount;             _balances[recipient] += amount;             emit Transfer(sender, recipient, amount);         }          if(!_isExcludedFromFee[sender] && !_isExcludedFromFee[recipient]){             uint256 amountForBurn = (amount * _burnFee) / 100;             uint256 amountForDev = (amount * _devFee) / 100;              uint256 amountToSend = amount - amountForBurn - amountForDev;              _balances[sender] = senderBalance - amountForDev - amountToSend;             _burn(sender, amountForBurn);              _balances[_devWalletAddress] += amountForDev;             emit Transfer(sender, _devWalletAddress, amountForDev);              _balances[recipient] += amountToSend;             emit Transfer(sender, recipient, amountToSend);         }     }      /** @dev Creates `amount` tokens and assigns them to `account`, increasing      * the total supply.      *      * Emits a {Transfer} event with `from` set to the zero address.      *      * Requirements:      *      * - `account` cannot be the zero address.      */     function _mint(address account, uint256 amount) internal virtual {         require(!mintingFinishedPermanent,\"cant be minted anymore!\");         require(account != address(0), \"ERC20: mint to the zero address\");          _beforeTokenTransfer(address(0), account, amount);          _totalSupply += amount;         _balances[account] += amount;         emit Transfer(address(0), account, amount);     }       /**      * @dev Destroys `amount` tokens from `account`, reducing the      * total supply.      *      * Emits a {Transfer} event with `to` set to the zero address.      *      * Requirements:      *      * - `account` cannot be the zero address.      * - `account` must have at least `amount` tokens.      */     function _burn(address account, uint256 amount) internal virtual {         require(account != address(0), \"ERC20: burn from the zero address\");          _beforeTokenTransfer(account, address(0), amount);          uint256 accountBalance = _balances[account];         require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");         _balances[account] = accountBalance - amount;         _totalSupply -= amount;          emit Transfer(account, address(0), amount);     }      /**      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.      *      * This internal function is equivalent to `approve`, and can be used to      * e.g. set automatic allowances for certain subsystems, etc.      *      * Emits an {Approval} event.      *      * Requirements:      *      * - `owner` cannot be the zero address.      * - `spender` cannot be the zero address.      */     function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), \"ERC20: approve from the zero address\");         require(spender != address(0), \"ERC20: approve to the zero address\");          _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     }      /**      * @dev Hook that is called before any transfer of tokens. This includes      * minting and burning.      *      * Calling conditions:      *      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens      * will be to transferred to `to`.      * - when `from` is zero, `amount` tokens will be minted for `to`.      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.      * - `from` and `to` are never both zero.      *      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].      */     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }      //exclude new owner from fees     function transferOwnership(address newOwner) public virtual override onlyOwner {         require(newOwner != address(0), \"Ownable: new owner is the zero address\");         _transferOwnership(newOwner);         _isExcludedFromFee[newOwner] = true;     } }"
        },
        {
            "name": "blog",
            "url": "https://linktr.ee/admin/links"
        }
    ],
    "tags": [
        "stablecoin",
        "privacy"
    ]
}